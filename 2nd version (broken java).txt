export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // Dashboard
    if (url.pathname === '/' || url.pathname === '/dashboard') {
      return new Response(getDashboardHTML(), {
        headers: { 'Content-Type': 'text/html; charset=utf-8' }
      });
    }
    
    // API endpoints
    if (url.pathname === '/api/feedback') {
      return handleFeedbackAPI(request, env);
    }
    
    if (url.pathname === '/api/analyze') {
      return handleAnalyzeAPI(env);
    }
    
    if (url.pathname === '/api/reset') {
      return handleResetAPI(env);
    }
    
    return new Response('Not Found', { status: 404 });
  }
};

// Handle feedback API with both KV and D1
async function handleFeedbackAPI(request, env) {
  try {
    if (request.method === 'GET') {
      // Get from KV storage
      const list = await env.FEEDBACK_KV.list();
      const feedback = [];
      
      for (const key of list.keys) {
        const item = await env.FEEDBACK_KV.get(key.name, 'json');
        if (item) feedback.push(item);
      }
      
      return new Response(JSON.stringify({
        success: true,
        data: feedback.reverse(),
        source: 'Cloudflare KV Storage',
        count: feedback.length
      }), {
        headers: { 
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        }
      });
    }
    
    if (request.method === 'POST') {
      const data = await request.json();
      const id = `feedback_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // 1. Store in KV (primary storage)
      await env.FEEDBACK_KV.put(id, JSON.stringify({
        id,
        ...data,
        timestamp: new Date().toISOString(),
        stored_in: 'cloudflare_kv'
      }));
      
      // 2. Store in D1 for analytics (if available)
      try {
        await env.DB.prepare(
          "INSERT INTO feedback (id, source, text, sentiment, urgency, timestamp) VALUES (?, ?, ?, ?, ?, ?)"
        ).bind(
          id,
          data.source || 'unknown',
          data.text || '',
          data.sentiment || 'neutral',
          data.urgency || 1,
          new Date().toISOString()
        ).run();
        
        console.log('âœ… Stored in D1 database');
      } catch (error) {
        console.log('âš ï¸ D1 not configured, using KV only:', error.message);
      }
      
      return new Response(JSON.stringify({
        success: true,
        id,
        stored_in: ['Cloudflare KV', 'Cloudflare D1'],
        timestamp: new Date().toISOString()
      }), {
        headers: { 
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*'
        }
      });
    }
    
    return new Response('Method not allowed', { status: 405 });
  } catch (error) {
    return new Response(JSON.stringify({
      error: error.message,
      stack: error.stack
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Handle analytics with D1
async function handleAnalyzeAPI(env) {
  try {
    // Try to use D1 first
    let analytics;
    let source = 'Cloudflare D1 Database';
    
    try {
      // Get analytics from D1
      const result = await env.DB.prepare(
        "SELECT source, sentiment, COUNT(*) as count FROM feedback GROUP BY source, sentiment"
      ).all();
      
      const summary = await env.DB.prepare(
        "SELECT COUNT(*) as total, AVG(urgency) as avg_urgency FROM feedback"
      ).first();
      
      analytics = {
        total: summary?.total || 0,
        avg_urgency: summary?.avg_urgency ? summary.avg_urgency.toFixed(2) : 0,
        breakdown: result?.results || [],
        source: 'Cloudflare D1'
      };
    } catch (d1Error) {
      // Fallback to KV if D1 fails
      console.log('D1 query failed, using KV:', d1Error.message);
      source = 'Cloudflare KV Storage';
      
      const list = await env.FEEDBACK_KV.list();
      const feedback = [];
      
      for (const key of list.keys) {
        const item = await env.FEEDBACK_KV.get(key.name, 'json');
        if (item) feedback.push(item);
      }
      
      const sources = {};
      const sentiments = {};
      let totalUrgency = 0;
      
      feedback.forEach(item => {
        sources[item.source] = (sources[item.source] || 0) + 1;
        sentiments[item.sentiment] = (sentiments[item.sentiment] || 0) + 1;
        totalUrgency += item.urgency || 0;
      });
      
      analytics = {
        total: feedback.length,
        avg_urgency: feedback.length > 0 ? (totalUrgency / feedback.length).toFixed(2) : 0,
        sources: sources,
        sentiments: sentiments,
        source: 'Cloudflare KV (D1 fallback)'
      };
    }
    
    // Cache in KV
    await env.FEEDBACK_KV.put('analytics_cache', JSON.stringify({
      ...analytics,
      cached_at: new Date().toISOString()
    }));
    
    return new Response(JSON.stringify(analytics), {
      headers: { 
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Analytics failed',
      message: error.message
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Reset endpoint
async function handleResetAPI(env) {
  if (env.ADMIN_KEY && new URL(request.url).searchParams.get('key') !== env.ADMIN_KEY) {
    return new Response('Unauthorized', { status: 401 });
  }
  
  // Clear KV
  const list = await env.FEEDBACK_KV.list();
  for (const key of list.keys) {
    await env.FEEDBACK_KV.delete(key.name);
  }
  
  // Clear D1 (if available)
  try {
    await env.DB.prepare("DELETE FROM feedback").run();
  } catch (error) {
    console.log('D1 clear failed:', error.message);
  }
  
  return new Response(JSON.stringify({
    success: true,
    cleared: list.keys.length,
    message: 'All feedback data cleared'
  }), {
    headers: { 'Content-Type': 'application/json' }
  });
}

// Dashboard HTML with architecture overview
function getDashboardHTML() {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Feedback Aggregator Dashboard</title>
  <style>
    :root {
      --cloudflare-orange: #f38020;
      --cloudflare-blue: #1e8feb;
      --cloudflare-purple: #8a4baf;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    .header {
      background: rgba(255, 255, 255, 0.95);
      padding: 25px;
      border-radius: 15px;
      margin-bottom: 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      margin: 0 0 10px 0;
    }
    .subtitle {
      color: #666;
      font-size: 16px;
    }
    .cloudflare-badge {
      display: inline-block;
      background: var(--cloudflare-orange);
      color: white;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      margin: 0 5px;
    }
    .architecture-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
      margin: 30px 0;
    }
    .product-card {
      background: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.1);
      transition: transform 0.3s ease;
    }
    .product-card:hover {
      transform: translateY(-5px);
    }
    .product-card.workers { border-top: 4px solid var(--cloudflare-orange); }
    .product-card.kv { border-top: 4px solid var(--cloudflare-blue); }
    .product-card.d1 { border-top: 4px solid var(--cloudflare-purple); }
    .metric-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin: 20px 0;
    }
    .metric-card {
      background: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 3px 10px rgba(0,0,0,0.1);
    }
    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 20px 0;
    }
    button {
      background: var(--cloudflare-orange);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    button:hover {
      background: #d96c0c;
      transform: translateY(-2px);
    }
    .result-panel {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      max-height: 400px;
      overflow-y: auto;
    }
    pre {
      background: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
      font-size: 12px;
    }
    .architecture-diagram {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin: 20px 0;
      font-family: monospace;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ“Š Feedback Aggregator Dashboard</h1>
      <p class="subtitle">Built with <span class="cloudflare-badge">Cloudflare Workers</span>, <span class="cloudflare-badge">KV</span>, and <span class="cloudflare-badge">D1</span></p>
      <p>Deployed at: <strong>feedback-dashboard.alexvillegas00.workers.dev</strong></p>
    </div>
    
    <div class="architecture-grid">
      <div class="product-card workers">
        <h3><span class="cloudflare-badge">Cloudflare Workers</span></h3>
        <p><strong>Purpose:</strong> Edge compute & hosting</p>
        <p><strong>Why:</strong> Global deployment with &lt;50ms latency</p>
        <p><strong>Implementation:</strong> Serves API and dashboard globally</p>
      </div>
      <div class="product-card kv">
        <h3><span class="cloudflare-badge">Cloudflare KV</span></h3>
        <p><strong>Purpose:</strong> Key-value storage</p>
        <p><strong>Why:</strong> Fast, persistent storage at the edge</p>
        <p><strong>Implementation:</strong> Stores feedback items with metadata</p>
      </div>
      <div class="product-card d1">
        <h3><span class="cloudflare-badge">Cloudflare D1</span></h3>
        <p><strong>Purpose:</strong> SQL database for analytics</p>
        <p><strong>Why:</strong> Complex queries and reporting</p>
        <p><strong>Implementation:</strong> Analytics and trend analysis</p>
      </div>
    </div>
    
    <div class="architecture-diagram">
      <h3>Architecture Overview</h3>
      <pre>
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Cloudflare Developer Platform                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Products Used:                                             â”‚
â”‚ 1. Cloudflare Workers - Edge compute & API serving         â”‚
â”‚ 2. Cloudflare KV - Key-value storage for feedback          â”‚
â”‚ 3. Cloudflare D1 - SQL database for analytics              â”‚
â”‚                                                            â”‚
â”‚ Data Flow:                                                 â”‚
â”‚                                                             â”‚
â”‚   Feedback â†’ Worker API â†’ Store in KV + D1 â†’ Dashboard     â”‚
â”‚                                                             â”‚
â”‚ Benefits:                                                  â”‚
â”‚ â€¢ Global deployment via 300+ edge locations                â”‚
â”‚ â€¢ Persistent storage with KV                               â”‚
â”‚ â€¢ SQL queries for complex analytics with D1                â”‚
â”‚ â€¢ Automatic scaling and high availability                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      </pre>
    </div>
    
    <div class="controls">
      <button onclick="addSample()">â• Add Sample Feedback</button>
      <button onclick="getFeedback()">ğŸ“‹ Get All Feedback</button>
      <button onclick="getAnalytics()">ğŸ“Š Get Analytics</button>
      <button onclick="resetData()" style="background: #dc3545;">ğŸ—‘ï¸ Reset Data</button>
    </div>
    
    <div class="metric-grid">
      <div class="metric-card">
        <h4>Total Feedback</h4>
        <h2 id="totalCount">0</h2>
      </div>
      <div class="metric-card">
        <h4>Storage Type</h4>
        <h2 id="storageType">KV</h2>
      </div>
      <div class="metric-card">
        <h4>Response Time</h4>
        <h2 id="responseTime">0ms</h2>
      </div>
      <div class="metric-card">
        <h4>Status</h4>
        <h2 id="status">Ready</h2>
      </div>
    </div>
    
    <div class="result-panel">
      <h3>API Results</h3>
      <pre id="output">Click buttons above to see results...</pre>
    </div>
  </div>
  
  <script>
    const API_BASE = window.location.origin;
    
    async function addSample() {
      setStatus('Adding sample feedback...');
      const start = Date.now();
      
      const sources = ['GitHub Issues', 'Discord Community', 'Email Support', 'Twitter', 'Community Forum'];
      const sentiments = ['positive', 'negative', 'neutral'];
      const texts = [
        'Great product! The new API is fantastic.',
        'Experiencing 500 errors with file uploads.',
        'Could we get more documentation for the Workers API?',
        'Customer support was very helpful today.',
        'Feature request: Add webhook notifications.'
      ];
      
      const data = {
        source: sources[Math.floor(Math.random() * sources.length)],
        text: texts[Math.floor(Math.random() * texts.length)],
        sentiment: sentiments[Math.floor(Math.random() * sentiments.length)],
        urgency: Math.floor(Math.random() * 5) + 1,
        category: 'feature'
      };
      
      try {
        const response = await fetch(API_BASE + '/api/feedback', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });
        
        const result = await response.json();
        const time = Date.now() - start;
        
        document.getElementById('output').textContent = JSON.stringify(result, null, 2);
        document.getElementById('responseTime').textContent = time + 'ms';
        setStatus('âœ… Added successfully');
        
        // Update total count
        setTimeout(getAnalytics, 500);
      } catch (error) {
        document.getElementById('output').textContent = 'Error: ' + error.message;
        setStatus('âŒ Failed');
      }
    }
    
    async function getFeedback() {
      setStatus('Fetching feedback...');
      const start = Date.now();
      
      try {
        const response = await fetch(API_BASE + '/api/feedback');
        const result = await response.json();
        const time = Date.now() - start;
        
        document.getElementById('output').textContent = JSON.stringify(result, null, 2);
        document.getElementById('responseTime').textContent = time + 'ms';
        setStatus('âœ… Retrieved');
        
        if (result.data) {
          document.getElementById('totalCount').textContent = result.data.length;
          document.getElementById('storageType').textContent = result.source || 'KV';
        }
      } catch (error) {
        document.getElementById('output').textContent = 'Error: ' + error.message;
        setStatus('âŒ Failed');
      }
    }
    
    async function getAnalytics() {
      setStatus('Analyzing data...');
      const start = Date.now();
      
      try {
        const response = await fetch(API_BASE + '/api/analyze');
        const result = await response.json();
        const time = Date.now() - start;
        
        document.getElementById('output').textContent = JSON.stringify(result, null, 2);
        document.getElementById('responseTime').textContent = time + 'ms';
        document.getElementById('storageType').textContent = result.source || 'D1';
        document.getElementById('totalCount').textContent = result.total || 0;
        setStatus('âœ… Analytics ready');
      } catch (error) {
        document.getElementById('output').textContent = 'Error: ' + error.message;
        setStatus('âŒ Failed');
      }
    }
    
    async function resetData() {
      if (!confirm('Are you sure you want to clear all feedback data?')) return;
      
      setStatus('Clearing data...');
      
      try {
        const response = await fetch(API_BASE + '/api/reset');
        const result = await response.json();
        
        document.getElementById('output').textContent = JSON.stringify(result, null, 2);
        document.getElementById('totalCount').textContent = '0';
        setStatus('âœ… Data cleared');
      } catch (error) {
        document.getElementById('output').textContent = 'Error: ' + error.message;
        setStatus('âŒ Failed');
      }
    }
    
    function setStatus(text) {
      document.getElementById('status').textContent = text;
      document.getElementById('status').style.color = text.includes('âœ…') ? '#28a745' : 
                                                      text.includes('âŒ') ? '#dc3545' : '#666';
    }
    
    // Initial load
    getAnalytics();
  </script>
</body>
</html>`;
}